# 模块自动检测功能说明

## 📋 功能概述

软件现在支持**自动检测LR8450设备上已安装的模块**，并根据检测结果动态显示可用的通道。

---

## ✨ 新增功能

### 1. **自动检测已安装的模块**

连接设备时，软件会自动检测UNIT1-UNIT4哪些插槽上安装了模块。

**检测原理：**
- 使用SCPI命令 `:UNIT:CHANnel? UNITx` 查询每个单元的通道数
- 如果通道数 > 0，说明该单元有模块
- 检测结果保存在 `self.installed_modules` 列表中

**示例输出：**
```
✓ 检测到 UNIT1: 30 个通道
✓ 检测到 UNIT2: 30 个通道
✓ 已安装的模块: UNIT[1, 2]
```

---

### 2. **未检测到模块时的提示**

如果设备上没有安装任何模块，软件会弹出警告对话框：

```
⚠️ 未检测到模块

设备已通过TCP/IP连接成功，但未检测到任何已安装的模块。

请检查：
1. 模块是否正确插入设备的UNIT插槽
2. 设备是否已识别模块

设备已连接，但无法进行数据采集。
```

---

### 3. **通道配置对话框动态显示可用通道**

打开"通道配置"对话框时，只会显示已安装模块的通道。

**示例：**
- **如果只安装了UNIT1**：通道下拉框只显示 `CH1_1` 到 `CH1_30`
- **如果安装了UNIT1和UNIT2**：通道下拉框显示 `CH1_1` 到 `CH1_30` 和 `CH2_1` 到 `CH2_30`
- **如果未连接设备**：显示所有单元的通道（UNIT1-UNIT4）

---

## 🔧 技术实现

### 1. **后端 - `lr8450_client.py`**

新增方法：`detect_installed_modules()`

```python
def detect_installed_modules(self) -> List[int]:
    """检测已安装的模块
    
    Returns:
        已安装模块的单元号列表，如 [1, 2] 表示UNIT1和UNIT2有模块
    """
    try:
        installed_modules = []
        
        # 查询每个单元是否有模块（通过查询通道数）
        for unit_num in range(1, 5):  # UNIT1 到 UNIT4
            response = self.query(f":UNIT:CHANnel? UNIT{unit_num}")
            
            if response:
                try:
                    channel_count = int(response.strip())
                    if channel_count > 0:
                        installed_modules.append(unit_num)
                        print(f"✓ 检测到 UNIT{unit_num}: {channel_count} 个通道")
                except ValueError:
                    pass
            
            time.sleep(0.1)
        
        return installed_modules
        
    except Exception as e:
        print(f"❌ 检测模块失败: {e}")
        return []
```

---

### 2. **前端 - `main_window.py`**

#### 修改1：添加 `installed_modules` 属性

```python
# 已安装的模块列表（连接设备后自动检测）
self.installed_modules: List[int] = []
```

#### 修改2：连接设备时检测模块

```python
# 连接
if self.device_client.connect():
    # 检测已安装的模块
    self.installed_modules = self.device_client.detect_installed_modules()
    
    # 如果没有检测到任何模块，提示用户
    if not self.installed_modules:
        QMessageBox.warning(
            self,
            "未检测到模块",
            "设备已连接成功，但未检测到任何已安装的模块..."
        )
        return
```

#### 修改3：传递模块信息给通道配置对话框

```python
def _show_channel_config_dialog(self) -> None:
    """显示通道配置对话框"""
    installed_modules = self.installed_modules if self.installed_modules else None
    dialog = ChannelConfigDialog(
        self, 
        current_config=self.channel_config,
        installed_modules=installed_modules
    )
```

---

### 3. **前端 - `channel_config_dialog.py`**

#### 修改1：接收 `installed_modules` 参数

```python
def __init__(self, parent=None, current_config=None, installed_modules=None):
    super().__init__(parent)
    
    # 已安装的模块列表（如果未提供，默认显示所有模块）
    self.installed_modules = installed_modules if installed_modules else [1, 2, 3, 4]
```

#### 修改2：动态生成通道列表

```python
def _create_channel_combo(self) -> QComboBox:
    """创建通道选择下拉框（根据已安装的模块动态生成）"""
    combo = QComboBox()
    
    # 根据已安装的模块添加通道
    for unit_num in self.installed_modules:
        for ch_num in range(1, 31):  # 每个模块最多30个通道
            channel_name = f"CH{unit_num}_{ch_num}"
            combo.addItem(channel_name, channel_name)
    
    return combo
```

---

## 🎯 使用流程

### **场景1：首次使用（未连接设备）**

1. 打开软件
2. 点击"通道配置"
3. 通道下拉框显示所有单元的通道（CH1_1 到 CH4_30）
4. 配置好通道后保存
5. 点击"连接设备"
6. 软件自动检测已安装的模块
7. 如果配置的通道不在已安装的模块上，会提示错误

---

### **场景2：先连接设备，再配置通道（推荐）**

1. 打开软件
2. 点击"连接设备"
3. 软件自动检测已安装的模块（如：UNIT1）
4. 点击"通道配置"
5. 通道下拉框**只显示UNIT1的通道**（CH1_1 到 CH1_30）
6. 配置通道并保存
7. 软件自动重新连接设备并应用配置
8. 开始测试

---

### **场景3：设备上没有模块**

1. 打开软件
2. 点击"连接设备"
3. 软件检测到设备上没有模块
4. 弹出警告对话框：
   ```
   ⚠️ 未检测到模块
   
   设备已连接成功，但未检测到任何已安装的模块。
   
   请检查：
   1. 模块是否正确插入设备的UNIT插槽
   2. 设备是否已识别模块
   ```
5. 用户插入模块后，重新点击"连接设备"

---

## 📝 默认配置变更

**旧的默认配置（硬编码为UNIT2）：**
```python
'ternary_voltage': {'channel': 'CH2_1', ...}
'ternary_temp': {'channel': 'CH2_3', ...}
'blade_voltage': {'channel': 'CH2_4', ...}
'blade_temp': {'channel': 'CH2_5', ...}
```

**新的默认配置（改为UNIT1）：**
```python
'ternary_voltage': {'channel': 'CH1_1', ...}
'ternary_temp': {'channel': 'CH1_3', ...}
'blade_voltage': {'channel': 'CH1_4', ...}
'blade_temp': {'channel': 'CH1_5', ...}
```

**原因：** UNIT1是第一个插槽，更符合常规使用习惯。

---

## 🧪 测试建议

### 1. **测试模块检测功能**

运行测试脚本：
```bash
python tests/test_module_detection.py
```

### 2. **测试不同模块配置**

- **测试1：只插入UNIT1模块**
  - 连接设备
  - 观察是否只检测到UNIT1
  - 打开通道配置，观察是否只显示CH1_x通道

- **测试2：插入UNIT1和UNIT2模块**
  - 连接设备
  - 观察是否检测到UNIT1和UNIT2
  - 打开通道配置，观察是否显示CH1_x和CH2_x通道

- **测试3：不插入任何模块**
  - 连接设备
  - 观察是否弹出"未检测到模块"警告

### 3. **测试数据采集**

- 配置通道为UNIT1的通道（如CH1_1, CH1_3, CH1_4, CH1_5）
- 开始采集数据
- 观察数据是否正常，是否还有错乱问题

---

## ✅ 解决的问题

1. ✅ **默认配置硬编码为UNIT2** → 改为UNIT1，更符合常规使用
2. ✅ **无法检测已安装的模块** → 自动检测并显示
3. ✅ **没有模块时没有提示** → 弹出警告对话框
4. ✅ **通道配置显示所有单元** → 只显示已安装模块的通道

---

## 🚀 后续优化建议

1. **保存模块检测结果到配置文件**
   - 下次打开软件时，如果未连接设备，可以使用上次检测的结果

2. **显示模块型号信息**
   - 使用 `:UNIT:TYPE? UNITx` 查询模块型号
   - 在通道配置对话框中显示模块型号（如：U8550）

3. **智能推荐通道配置**
   - 根据检测到的模块类型，自动推荐合适的通道配置
   - 例如：检测到电压模块，推荐电压通道；检测到温度模块，推荐温度通道

---

## 📞 如有问题

如果测试中发现任何问题，请告诉我：
1. 设备上实际插入了哪些模块（UNIT1/UNIT2/UNIT3/UNIT4）
2. 软件检测到了哪些模块
3. 通道配置对话框显示了哪些通道
4. 数据采集是否正常

我会立即帮你解决！🚀

